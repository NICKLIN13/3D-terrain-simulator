<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>3D terrain simulator</title>
    <script src="math.js"></script>


    <script id="vertex" type="glsl">
        #version 300 es
        layout(location=0) in vec4 position;
        layout(location=1) in vec3 normal;

        uniform mat4 mv;
        uniform mat4 p;

        out vec3 vnormal;

        void main() {
            gl_Position = p * mv * position;
            vnormal = mat3(mv) * normal;
        }
    </script>

    <script id="frag" type="glsl">
        #version 300 es
        precision highp float;
        uniform vec4 color;

        uniform vec3 lightdir;
        uniform vec3 lightcolor;
        uniform vec3 halfway;

        out vec4 fragColor;
        in vec3 vnormal;

        void main() {
            vec3 n = normalize(vnormal);
            vec3 ld = lightdir;
            float lambert = max(dot(n, lightdir), 0.0);
            float blinn = pow(max(dot(n, halfway), 0.0), 300.0);
            fragColor = vec4(color.rgb * (lightcolor * lambert) + (vec3(0.8,0.8,0.8) * blinn) * 0.5, color.a);
        }
    </script>


    <!-- Setup -->
    <script>
        const IlliniBlue = new Float32Array([0.075, 0.16, 0.292, 1])
        const IlliniOrange = new Float32Array([1, 0.373, 0.02, 1])
        const IdentityMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
        const EarthTone = new Float32Array([0.823, 0.706, 0.549, 1])

        /**
         * Compiles the provided vertex and fragment shader sources
         * and links them into a usable WebGL program.
         */
        function compileShader(vs_source, fs_source) {
            const vs = gl.createShader(gl.VERTEX_SHADER)
            gl.shaderSource(vs, vs_source)
            gl.compileShader(vs)
            if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(vs))
                throw Error("Vertex shader compilation failed")
            }

            const fs = gl.createShader(gl.FRAGMENT_SHADER)
            gl.shaderSource(fs, fs_source)
            gl.compileShader(fs)
            if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(fs))
                throw Error("Fragment shader compilation failed")
            }

            const program = gl.createProgram()
            gl.attachShader(program, vs)
            gl.attachShader(program, fs)
            gl.linkProgram(program)
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program))
                throw Error("Linking failed")
            }

            const uniforms = {}
            for (let i = 0; i < gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS); i += 1) {
                let info = gl.getActiveUniform(program, i)
                uniforms[info.name] = gl.getUniformLocation(program, info.name)
            }
            program.uniforms = uniforms

            return program
        }

        /**
         * Sends per-vertex data to the GPU and connects it to a VS input
         * 
         * @param data    a 2D array of per-vertex data (e.g. [[x,y,z,w],[x,y,z,w],...])
         * @param loc     the layout location of the vertex shader's `in` attribute
         * @param mode    (optional) gl.STATIC_DRAW, gl.DYNAMIC_DRAW, etc
         * 
         * @returns the ID of the buffer in GPU memory; useful for changing data later
         */
        function supplyDataBuffer(data, loc, mode) {
            if (mode === undefined) mode = gl.STATIC_DRAW

            const buf = gl.createBuffer()
            gl.bindBuffer(gl.ARRAY_BUFFER, buf)
            const f32 = new Float32Array(data.flat())
            gl.bufferData(gl.ARRAY_BUFFER, f32, mode)

            gl.vertexAttribPointer(loc, data[0].length, gl.FLOAT, false, 0, 0)
            gl.enableVertexAttribArray(loc)

            return buf;
        }

        /**
         * Creates a Vertex Array Object and puts into it all of the data in the given
         * JSON structure, which should have the following form:
         * 
         * ````
         * {"triangles": a list of of indices of vertices
         * ,"attributes":
         *  [ a list of 1-, 2-, 3-, or 4-vectors, one per vertex to go in location 0
         *  , a list of 1-, 2-, 3-, or 4-vectors, one per vertex to go in location 1
         *  , ...
         *  ]
         * }
         * ````
         * 
         * @returns an object with four keys:
         *  - mode = the 1st argument for gl.drawElements
         *  - count = the 2nd argument for gl.drawElements
         *  - type = the 3rd argument for gl.drawElements
         *  - vao = the vertex array object for use with gl.bindVertexArray
         */
        function setupGeomery(geom) {
            var triangleArray = gl.createVertexArray()
            gl.bindVertexArray(triangleArray)

            for (let i = 0; i < geom.attributes.length; i += 1) {
                let data = geom.attributes[i]
                supplyDataBuffer(data, i)
            }

            var indices = new Uint16Array(geom.triangles.flat())
            var indexBuffer = gl.createBuffer()
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW)

            return {
                mode: gl.TRIANGLES,
                count: indices.length,
                type: gl.UNSIGNED_SHORT,
                vao: triangleArray
            }
        }
    </script>


    <!-- All the other code -->
    <script>

        function fillScreen() {
            let canvas = document.querySelector('canvas')
            document.body.style.margin = '0'
            canvas.style.width = '100%'
            canvas.style.height = '100%'
            canvas.width = canvas.clientWidth
            canvas.height = canvas.clientHeight
            canvas.style.width = ''
            canvas.style.height = ''
            gl.viewport(0, 0, canvas.width, canvas.height)
            window.p = m4perspNegZ(0.1, 15, 1.0, canvas.width, canvas.height)
        }

        function draw(seconds) {

            gl.clearColor(...IlliniBlue)
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

            if (window.temp == null) return;

            gl.useProgram(program)
            gl.uniform4fv(program.uniforms.color, EarthTone)

            let ld = normalize([1, 1, 1])
            let h = normalize(add(ld, [0, 0, 1]))// The sum of the light direction(lightdir) and eye vector(view coordinates)
            gl.uniform3fv(program.uniforms.lightdir, ld)
            gl.uniform3fv(program.uniforms.lightcolor, [1, 1, 1])
            gl.uniform3fv(program.uniforms.halfway, h)

            gl.bindVertexArray(geomGrid.vao)

            // MOVING CAMERA
            let m = IdentityMatrix
            let forwardVec = normalize(sub(lookingAt, cameraVec))
            let globalUp = [0, 1, 0]
            let rightVec = normalize(cross(forwardVec, globalUp))
            let scaledforwardVec = mul(forwardVec, 0.03)
            let scaledrightVec = mul(rightVec, 0.03)
            let upVec = normalize(cross(forwardVec, rightVec))
            let scaledUpVec = mul(upVec, 0.03)


            // camera adjustment
            if (keysBeingPressed['w']) { // move up
                cameraVec = add(cameraVec, scaledforwardVec)
            } else if (keysBeingPressed['s']) { // move down
                cameraVec = sub(cameraVec, scaledforwardVec)
            } else if (keysBeingPressed['a']) { // move left
                lookingAt = sub(lookingAt, scaledrightVec)
                cameraVec = sub(cameraVec, scaledrightVec)
            } else if (keysBeingPressed['d']) { // move right
                lookingAt = add(lookingAt, scaledrightVec)
                cameraVec = add(cameraVec, scaledrightVec)
            }


            if (keysBeingPressed['ArrowLeft']) { // pan left
                lookingAt = sub(lookingAt, scaledrightVec)
            } else if (keysBeingPressed['ArrowRight']) { // pan right
                lookingAt = add(lookingAt, scaledrightVec)
            } else if (keysBeingPressed['ArrowUp']) { // pitch up
                lookingAt = sub(lookingAt, scaledUpVec)
            } else if (keysBeingPressed['ArrowDown']) { // pitch down
                lookingAt = add(lookingAt, scaledUpVec)
            }


            let v = m4view(cameraVec, lookingAt, [0, 1, 0])
            gl.uniformMatrix4fv(program.uniforms.m, false, m)
            gl.uniformMatrix4fv(program.uniforms.mv, false, m4mul(v, m))
            gl.uniformMatrix4fv(program.uniforms.p, false, p)
            gl.drawElements(geomGrid.mode, geomGrid.count, geomGrid.type, 0)


        }

        /** Compute any time-varying or animated aspects of the scene */
        function tick(milliseconds) {
            let seconds = milliseconds / 1000;
            draw(seconds)
            requestAnimationFrame(tick)
        }


        function generateGrid(gridsize) {
            for (let i = 0; i < gridsize; i += 1) {
                window.temp[i] = new Array(gridsize).fill(0);
            }
            console.log("generateGrid！");
        }

        function faulting(faults) {
            const delta = 50;
            const R = 200;
            for (let i = 0; i < faults; i += 1) {

                const randomCoor1 = Math.floor(Math.random() * gridsize)
                const randomCoor2 = Math.floor(Math.random() * gridsize)
                window.rp = [randomCoor1, randomCoor2]

                const theta = Math.random() * 2 * Math.PI; // random θ, and theta is between 0 and 2π
                const x = Math.cos(theta);
                const z = Math.sin(theta);
                window.sn = [x, z]

                // get the dot product of every point with rp
                for (let j = 0; j < gridsize; j += 1) {
                    for (let k = 0; k < gridsize; k += 1) {
                        const b = sub([j, k], rp);

                        const r = Math.sqrt(b[0] ** 2 + b[1] ** 2);
                        let coef;
                        if (r < R) {
                            coef = (1 - (r / R) ** 2) ** 2;
                        } else {
                            coef = 0;
                        }
                        const dynamicDelta = delta * coef;

                        const dotProduct = dot(b, sn);
                        if (dotProduct >= 0) {
                            window.temp[j][k] += dynamicDelta
                        } else {
                            window.temp[j][k] -= dynamicDelta
                        }
                    }
                }
            }
            console.log("faulting！")
        }


        function normalizeHeights(faults) {
            if (faults > 0) {
                let min = Infinity;
                let max = -Infinity;

                for (let i = 0; i < gridsize; i += 1) {
                    for (let j = 0; j < gridsize; j += 1) {
                        min = Math.min(min, temp[i][j]);
                        max = Math.max(max, temp[i][j]);
                    }
                }

                const c = 1.6
                if (max !== min) {
                    for (let i = 0; i < gridsize; i += 1) {
                        for (let j = 0; j < gridsize; j += 1) {
                            temp[i][j] = (c * (temp[i][j] - (0.5 * (max + min)))) / (max - min)

                        }
                    }
                }
            } else {
                console.error("Please check normalizeHeights")
                return
            }
            console.log("normalizeHeights！")
        }


        function generateGeom() {
            console.log("check temp：", temp);
            if (window.temp == null) return;

            const gridsize = temp.length;
            const geom = {
                attributes: [[]],
                triangles: []
            };

            // transform x&z coor to -1~1
            function calculateNormCoor(i, j) {
                const normX = (i / (gridsize - 1)) * 2 - 1;
                const normZ = (j / (gridsize - 1)) * 2 - 1;
                return { normX, normZ };
            }

            for (let i = 0; i < gridsize - 1; i++) {
                for (let j = 0; j < gridsize - 1; j++) {

                    // split grid into 2 triangles
                    const curr = i * gridsize + j;
                    const next = (i + 1) * gridsize + j;
                    geom.triangles.push([curr, curr + 1, next]);
                    geom.triangles.push([curr + 1, next + 1, next]);

                    // transform x&z coor to -1~1
                    const { normX, normZ } = calculateNormCoor(i, j);
                    const normY = temp[i][j];
                    geom.attributes[0].push([normX, normY, normZ]);
                }

                // last point in curr
                const { normX: lastX, normZ: lastZ } = calculateNormCoor(i, gridsize - 1);
                const lastY = temp[i][gridsize - 1];
                geom.attributes[0].push([lastX, lastY, lastZ]);
            }

            // last row
            for (let j = 0; j < gridsize; j++) {
                const normX = 1;
                const normY = temp[gridsize - 1][j];
                const normZ = (j / (gridsize - 1)) * 2 - 1;
                geom.attributes[0].push([normX, normY, normZ]);
            }

            console.log("generateGeom！", geom);
            return geom;
        }


        function generateRandomPoint() {
            const randomCoor1 = Math.floor(Math.random() * gridsize)
            const randomCoor2 = Math.floor(Math.random() * gridsize)
            return [randomCoor1, randomCoor2]
        }

        function getRandomNormalVector() {
            const theta = Math.random() * 2 * Math.PI; // random θ, and theta is between 0 and 2π
            const x = Math.cos(theta);
            const z = Math.sin(theta);
            const surfaceNormal = [x, z]
            return surfaceNormal;
        }

        function addNormals(geom) {
            let ni = geom.attributes.length
            geom.attributes.push([])
            for (let i = 0; i < geom.attributes[0].length; i += 1) {
                geom.attributes[ni].push([0, 0, 0])
            }
            for (let i = 0; i < geom.triangles.length; i += 1) {
                let p0 = geom.attributes[0][geom.triangles[i][0]]
                let p1 = geom.attributes[0][geom.triangles[i][1]]
                let p2 = geom.attributes[0][geom.triangles[i][2]]
                let e1 = sub(p1, p0)
                let e2 = sub(p2, p0)
                let n = cross(e1, e2)
                geom.attributes[ni][[geom.triangles[i][0]]] = add(geom.attributes[ni][[geom.triangles[i][0]]], n)
                geom.attributes[ni][[geom.triangles[i][1]]] = add(geom.attributes[ni][[geom.triangles[i][1]]], n)
                geom.attributes[ni][[geom.triangles[i][2]]] = add(geom.attributes[ni][[geom.triangles[i][2]]], n)
            }
            for (let i = 0; i < geom.attributes[0].length; i += 1) {
                geom.attributes[ni][i] = normalize(geom.attributes[ni][i])
            }
            console.log("addNormals！")
        }


        function randomGridsize() {
            let randomGridsize = Math.floor(Math.random() * (30 - 2 + 1)) + 2
            return randomGridsize
        }

        function randomFaults() {
            let randomFaults = Math.floor(Math.random() * (50 - 2 + 1))
            return randomFaults

        }


        window.addEventListener('load', async (event) => {
            window.gl = document.querySelector('canvas').getContext('webgl2',
                { antialias: false, depth: true, preserveDrawingBuffer: true }
            )
            let vs = document.querySelector('#vertex').textContent.trim()
            let fs = document.querySelector('#frag').textContent.trim()
            window.program = compileShader(vs, fs)
            gl.enable(gl.DEPTH_TEST)
            gl.enable(gl.BLEND) // enable transparency
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA) // enable transparency


            window.gridsize = randomGridsize()
            const faults = randomFaults()

            window.temp = new Array(gridsize)
            generateGrid(gridsize)
            faulting(faults)
            normalizeHeights(faults)
            let geom = generateGeom()
            addNormals(geom)
            window.geomGrid = setupGeomery(geom);

            // track which key is down or up
            window.keysBeingPressed = {}
            window.addEventListener('keydown', event => keysBeingPressed[event.key] = true)
            window.addEventListener('keyup', event => keysBeingPressed[event.key] = false)
            window.cameraVec = [0, 1.3, 2]
            window.lookingAt = [0, 0, 0]


            fillScreen()
            window.addEventListener('resize', fillScreen)
            draw()
            requestAnimationFrame(tick)
        })

    </script>
    <style>
        body {
            margin: 0;
            border: none;
            padding: 0;
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100vh;
        }

        .controls {
            flex: 0 0 auto;
        }

        .controls>* {
            margin: 1em;
        }

        .display {
            flex-grow: 1;
            line-height: 0rem;
        }
    </style>
</head>

<body>
    <div class="display">
        <canvas width="300" height="300"></canvas>
    </div>
</body>

</html>